(defpackage lila
  (:use cl)
  (:import-from clvm *vm* column dump-stack emit-forms new-id-form new-pos new-vm line parse-int parse-ws pc vm-eval)
  (:import-from utils kw ws?)
  (:export parse-form parse-id))

(in-package lila)

(define-symbol-macro *version* 1)

(defun parse-id (in pos)
  (let ((fpos pos)
	(s (with-output-to-string (out)
	     (labels ((rec ()
			(let ((c (read-char in nil)))
			  (when c
			    (if (ws? c)
				(unread-char c in)
				(progn
				  (incf (column pos))
				  (write-char c out)
				  (rec)))))))
	       (rec)))))
    (unless (zerop (length s))
      (new-id-form (kw s) :pos fpos))))

(defun parse-form (in pos)
  (or (parse-ws in pos)
      (parse-int in pos)
      (parse-id in pos)))

(defun repl (&key (in *standard-input*) (out *standard-output*))
  (flet ((fmt (spec &rest args)
           (apply #'format out spec args)
           (finish-output out)))
    (fmt "lila v~a~%" *version*)
    (fmt "Press Return twice to evaluate.~%~%")
    (fmt "May the source be with you!~%~%")

    (with-output-to-string (buf)
      (labels ((get-line ()
		 (fmt "  ")
		 (let ((lin (read-line in nil)))
		   (when lin
		     (if (string= lin "")
			 (let ((fin (make-string-input-stream (get-output-stream-string buf)))
			       (start-pc (pc))
			       (pos (new-pos "repl")))
			   (labels ((get-forms (out)
				      (let ((f (parse-form fin pos)))
					(if f
					    (get-forms (cons f out))
					    (nreverse out)))))
			     (emit-forms (get-forms nil)))
			   (vm-eval :pc start-pc)
			   (dump-stack)
			   (terpri out))
			 (write-string lin buf))
		     (get-line)))))
	(get-line)))))
