func fibr (n Int) (Int) 
  if n.< 2 n + fibr n.- 1 fibr n.- 2

bench 100 fibr -d -u 20

func fibt (n Int a Int b Int) (Int)
  if n.is 0 a if n.is 1 b fibt -u n.- 1 b a.+ b

bench 10000 fibt -d -u 70 0 1

* add t/tco call flag
* join store/load on same reg
** add store.pop?
* add m/mem call flag
* copy load op type propagation logic from alisp func
* type check func rets
* add stack type
** add stack prim
** push copy of stack
** readme
* add iters
** add for prim
* add vset.lisp
** based on ordinary vector
** binary search
** take compare/key as find args
** use (replace) to move items
** add new-set constructor from iter
*** start empty and insert one at a time
* add multi
* add refs
** &foo
** require id form
** push value as is
* add struct defs
** struct.lisp struct-def struct-vsl
** store as field vector + version
** add struct prim
** dot field access

struct pos () (x Int y Int)
